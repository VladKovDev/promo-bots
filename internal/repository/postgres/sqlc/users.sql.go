// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one
SELECT
    COUNT(*)
FROM
    users
WHERE
    is_active = TRUE
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (
        telegram_id,
        username,
        first_name,
        last_name,
        role
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5
    ) RETURNING id,
    telegram_id,
    username,
    first_name,
    last_name,
    role,
    created_at,
    is_active,
    blocked_at
`

type CreateUserParams struct {
	TelegramID *int64  `json:"telegram_id"`
	Username   *string `json:"username"`
	FirstName  *string `json:"first_name"`
	LastName   *string `json:"last_name"`
	Role       string  `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.TelegramID,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.BlockedAt,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :one
UPDATE
    users
SET
    is_active = FALSE,
    blocked_at = NOW()
WHERE
    id = $1
    AND is_active = TRUE RETURNING id
`

func (q *Queries) DeactivateUser(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deactivateUser, id)
	err := row.Scan(&id)
	return id, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id,
    telegram_id,
    username,
    first_name,
    last_name,
    role,
    created_at,
    is_active,
    blocked_at
FROM
    users
WHERE
    id = $1
    AND is_active = TRUE
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.BlockedAt,
	)
	return i, err
}

const getUserByTelegramID = `-- name: GetUserByTelegramID :one
SELECT
    id,
    telegram_id,
    username,
    first_name,
    last_name,
    role,
    created_at,
    is_active,
    blocked_at
FROM
    users
WHERE
    telegram_id = $1
    AND is_active = TRUE
`

func (q *Queries) GetUserByTelegramID(ctx context.Context, telegramID *int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByTelegramID, telegramID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.BlockedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT
    id,
    telegram_id,
    username,
    first_name,
    last_name,
    role,
    created_at,
    is_active,
    blocked_at
FROM
    users
WHERE
    is_active = TRUE
ORDER BY
    created_at DESC
LIMIT
    $2 OFFSET $1
`

type ListUsersParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TelegramID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.CreatedAt,
			&i.IsActive,
			&i.BlockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByRole = `-- name: ListUsersByRole :many
SELECT
    id,
    telegram_id,
    username,
    first_name,
    last_name,
    role,
    created_at,
    is_active,
    blocked_at
FROM
    users
WHERE
    role = $1
    AND is_active = TRUE
ORDER BY
    created_at DESC
LIMIT
    $3 OFFSET $2
`

type ListUsersByRoleParams struct {
	Role      string `json:"role"`
	OffsetVal int32  `json:"offset_val"`
	LimitVal  int32  `json:"limit_val"`
}

func (q *Queries) ListUsersByRole(ctx context.Context, arg ListUsersByRoleParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByRole, arg.Role, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TelegramID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.CreatedAt,
			&i.IsActive,
			&i.BlockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE
    users
SET
    telegram_id = $1,
    username = $2,
    first_name = $3,
    last_name = $4,
    role = $5
WHERE
    id = $6
    AND is_active = TRUE RETURNING id,
    telegram_id,
    username,
    first_name,
    last_name,
    role,
    created_at,
    is_active,
    blocked_at
`

type UpdateUserParams struct {
	TelegramID *int64      `json:"telegram_id"`
	Username   *string     `json:"username"`
	FirstName  *string     `json:"first_name"`
	LastName   *string     `json:"last_name"`
	Role       string      `json:"role"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.TelegramID,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Role,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.CreatedAt,
		&i.IsActive,
		&i.BlockedAt,
	)
	return i, err
}

const userExistsByTelegramID = `-- name: UserExistsByTelegramID :one
SELECT
    EXISTS(
        SELECT
            1
        FROM
            users
        WHERE
            telegram_id = $1
            AND is_active = TRUE
    )
`

func (q *Queries) UserExistsByTelegramID(ctx context.Context, telegramID *int64) (bool, error) {
	row := q.db.QueryRow(ctx, userExistsByTelegramID, telegramID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
